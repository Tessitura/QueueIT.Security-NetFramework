<?xml version="1.0" encoding="utf-8"?>
<topic id="349d3a93-2dde-48db-8f56-5876c5e079b3" revisionNumber="1">
  <developerTroubleshootingDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">

    <!--
    <summary>
      <para>Optional summary abstract</para>
    </summary>
    -->

    <introduction>
      <!-- Uncomment this to generate an outline of the section and sub-section
           titles.  Specify a numeric value as the inner text to limit it to
           a specific number of sub-topics when creating the outline.  Specify
           zero (0) to limit it to top-level sections only.  -->
      <!-- <autoOutline /> -->

      <para>Anwsers to frequently asked questions</para>
    </introduction>

    <!-- Zero or more sections.  These are collapsible.  If using
         <autoOutline />, add an address attribute to identify it and specify
         a title so that it can be jumped to with a hyperlink. -->
    <section address="ValidationFails">
      <title>I have implemented Known User security, but validation fails?</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline /> -->
        <para>
          When validating the Known User token the entire URL is validated to ensure that it has not been tampered with.
          Therefore, if your application does URL rewrite or any of your network equipment
          alteres the URL in any way, the Known User validation will fail. This could for example be a load balancer that forwards https trafic to http (thereby
          altering the URL from https:// to http:/) or forwards requests to another port number. In this case you will need to
          translate the URL back to its original form before validating the Known User token. See <link xlink:href="9c770124-51d9-49ed-90ae-c209b6471f5b" >Pitfalls</link>
        </para>
        <para>
          In this case you need to override the default url provider. Below you can see an example of this.
        </para>
        <code language="csharp">
          public class MyCustomUrlProvider : DefaultKnownUserUrlProvider
          {
            public override Uri GetUrl()
            {
              string internalUrl = base.GetUrl().ToString();
              string publicUrl = internalUrl.Replace("http", "https").Replace(":4490", "");
              return new Uri(publicUrl);
            }
          }
        </code>
        <para>
          Then register the implementation with the KnownUserFactory or provide the implementation to the KnownUserFactory.VerifyMd5Hash method. The registration should only be done once.
        </para>
        <code language="csharp">
          KnownUserFactory.Configure(urlProviderFactory: () => new MyCustomUrlProvider());
        </code>
        <!-- <procedure>Optional procedures.  See How To document for procedure layout example.</procedure> -->
      </content>
    </section>

    <section address="RedirectedBackToQueue">
      <title>The Known User token validates but I am sent back to the queue when loading a new page?</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline /> -->
        <para>
          When the Known User
          token is successfully validated a session is created. By default this session is stored in a cookie generated by 
          <codeEntityReference>T:QueueIT.Security.CookieValidateResultRepository</codeEntityReference>. Therefore the user
          will be sent back into the queue if the browser does not allow cookies or the cookie is not beeing forwarded by e.g.
          caching servers. We reccomend that the application always verifies that the browser supports cookies and if not shows 
          an error before sending the user to the queue.
        </para>
        <!-- <procedure>Optional procedures.  See How To document for procedure layout example.</procedure> -->
      </content>
    </section>
    
    <section address="CancelToken">
      <title>Can I cancel a validation result?</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline /> -->
        <para>
          You can cancel a validated result at any time - e.g. if you want the user to be placed at the begining of the line when a
          purchase is completed. Cancelling requires two steps. First the browser session must be canceled and secondly the 
          Queue ID must be canceled so it cannot be reused. The session is canceled by invoking the 
          <codeEntityReference>M:QueueIT.Security.AcceptedConfirmedResult.Cancel</codeEntityReference> method on the 
          <codeEntityReference>T:QueueIT.Security.AcceptedConfirmedResult</codeEntityReference>. The Queue ID is canceled through 
          the API or by redirecting the browser to a Queue-it URL (we will send the browser right back).
        </para>
        <code language="csharp">
          IValidateResult result = SessionValidationController.ValidateRequest();
          var accepted = result as AcceptedConfirmedResult;

          if (accepted != null)
          {
            accepted.Cancel(); // cancels session

            string returnTo = "http://mysite.com";
            Response.Redirect(accepted.Queue.GetCancelUrl(returnTo)); // cancels Queue ID
          }
        </code>
        <!-- <procedure>Optional procedures.  See How To document for procedure layout example.</procedure> -->
      </content>
    </section>

    <section address="SetExpiration">
      <title>Can I set the session expiration time on individual request?</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline /> -->
        <para>
          Once the Known User token is validated the deafult the expiration time is 20 minutes. Every time the ValidateRequest 
          method on the <codeEntityReference>T:QueueIT.Security.SessionValidationController</codeEntityReference> class is
          invoked the expiration time is extended. You can configure a different default expiration time or you can set the
          expiration time on individual request by invoking the
          <codeEntityReference>M:QueueIT.Security.AcceptedConfirmedResult.SetExpiration(System.DateTime)</codeEntityReference> 
          method. E.g. you may want to extend the expiration time when the user is in the checkout section of your website.
        </para>
        <code language="csharp">
          IValidateResult result = SessionValidationController.ValidateRequest();
          var accepted = result as AcceptedConfirmedResult;

          if (accepted != null)
          {
            accepted.SetExpiration(DateTime.UtcNow.AddMinutes(45)); 
          }
        </code>
        <!-- <procedure>Optional procedures.  See How To document for procedure layout example.</procedure> -->
      </content>
    </section>

    <section address="KeepIdleUsers">
      <title>I want users that arrive to my website while the queue is in idle mode to stay on the website?</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline /> -->
        <para>
          Visitors that arrive while the queue is in idle mode and the idle logic is configured to send users to the target will by
          default be sent to the queue once the pre queue is active. I you want visitors to stay on your website and only send new
          visitors to the queue you need to manually expend the session expiration by invoking the
          <codeEntityReference>M:QueueIT.Security.AcceptedConfirmedResult.SetExpiration(System.DateTime)</codeEntityReference> 
          method.
        </para>
        <code language="csharp">
          IValidateResult result = SessionValidationController.ValidateRequest();
          var accepted = result as AcceptedConfirmedResult;

          if (accepted != null)
          {
            if (accepted.KnownUser.RedirectType == RedirectType.Idle)
              accepted.SetExpiration(DateTime.UtcNow.AddMinutes(20));
          }
        </code>
        <!-- <procedure>Optional procedures.  See How To document for procedure layout example.</procedure> -->
      </content>
    </section>

    <section address="SetFixedExpiration">
      <title>Can I set a fixed expiration time?</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline /> -->
        <para>
          You can set a fixed expiration time using the timestamp of the Known User Token 
          <codeEntityReference>P:QueueIT.Security.IKnownUser.TimeStamp</codeEntityReference> and the 
          <codeEntityReference>M:QueueIT.Security.AcceptedConfirmedResult.SetExpiration(System.DateTime)</codeEntityReference> 
          method. E.g. you may want to allow the user to browse you site two hours after validating the Known User Token.
        </para>
        <code language="csharp">
          IValidateResult result = SessionValidationController.ValidateRequest();
          var accepted = result as AcceptedConfirmedResult;

          if (accepted != null)
          {
            accepted.SetExpiration(accepted.KnownUser.TimeStamp.AddHours(2));
          }
        </code>
        <!-- <procedure>Optional procedures.  See How To document for procedure layout example.</procedure> -->
      </content>
    </section>

    <section address="NoSessionValidationController">
      <title>The SessionValidationController does not work the way I want, can I not use it?</title>
      <content>
        <!-- Uncomment this to create a sub-section outline
        <autoOutline /> -->
        <para>
          The <codeEntityReference>T:QueueIT.Security.SessionValidationController</codeEntityReference> combines the 
          functionality of the <codeEntityReference>T:QueueIT.Security.KnownUserFactory</codeEntityReference> and the
          <codeEntityReference>T:QueueIT.Security.QueueFactory</codeEntityReference> and adds session state. If you prefer
          managing your own session or have an advanced use case that is not supported by the
          <codeEntityReference>T:QueueIT.Security.SessionValidationController</codeEntityReference> you can use the above 
          mentioned types directly. See type members for more information and examples.
        </para>
        <!-- <procedure>Optional procedures.  See How To document for procedure layout example.</procedure> -->
      </content>
    </section>

    <relatedTopics>
      <!-- One or more of the following:
           - A local link
           - An external link
           - A code entity reference

      <link xlink:href="Other Topic's ID">Link text</link>
      <externalLink>
          <linkText>Link text</linkText>
          <linkAlternateText>Optional alternate link text</linkAlternateText>
          <linkUri>URI</linkUri>
      </externalLink>
      <codeEntityReference>API member ID</codeEntityReference>

      Examples:

      <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8278">Some other topic</link>

      <externalLink>
          <linkText>SHFB on CodePlex</linkText>
          <linkAlternateText>Go to CodePlex</linkAlternateText>
          <linkUri>http://shfb.codeplex.com</linkUri>
      </externalLink>

      <codeEntityReference>T:TestDoc.TestClass</codeEntityReference>
      <codeEntityReference>P:TestDoc.TestClass.SomeProperty</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.#ctor(System.String,System.Int32)</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.ToString</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.FirstMethod</codeEntityReference>
      <codeEntityReference>M:TestDoc.TestClass.SecondMethod(System.Int32,System.String)</codeEntityReference>
      -->
    </relatedTopics>
  </developerTroubleshootingDocument>
</topic>
